#include "../utils/cryptoUtil.h"
#include "../utils/fileUtil.h"
#include "../utils/stringUtil.h"
#include "../utils/argumentsParserUtil.h"
#include "../utils/converter.h"
#include "../enums/boolean.h"
#include "../types/argumentsParsed.h"
#include "../types/hashTable.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>
#include <limits.h>
#include <pthread.h>

typedef struct ThreadData {
    FILE *file;
    long startPositionSeek;
    long endPositionSeek;
    ArgumentsParsed *argumentsParsed;
    int hashLength;
    HashTableMultiLayer *hashTableML; 
} ThreadData;

void printClearPass(FILE *rainbowTable, long seekPosOfClearPass, unsigned char * hash, int hashLength)
{
    if (fseek(rainbowTable, seekPosOfClearPass, SEEK_SET) != 0)
    {
        perror("Erreur lors du déplacement du curseur de fichier");
        rewind(rainbowTable);
    }

    char buffer[1024];
    size_t bytesRead = fread(buffer, 1, sizeof(buffer) - 1, rainbowTable);
    if (bytesRead > 0)
    {
        buffer[bytesRead] = '\0';
        printf("\n\n=====>");
        printf("\n=====> MATCH ");
        printHashAsStr(hash, hashLength);
        printf(" ");

        for (int i = 0; i < 1024; i++)
        {
            if (buffer[i] == '\n')
                break;
            printf("%c", buffer[i]);
        }
        printf("\n");

    }
}

int findHashBytesLengthFromFile(FILE *rainbowTable)
{

    rewind(rainbowTable);
    
    char line[1024];

    
    // firt line which is an header in our rainbow tablen currently compase like "{HashAlog};{LengthOfHash}"
    fgets(line, sizeof(line), rainbowTable);

    printf("Seek currently at %ld\n\n", ftell(rainbowTable));
    // firt line which is an header in our rainbow table
    Algorythme algo = strToAlgorythme(line);
    int lengthHash = algoToByteLength(algo);
    rewind(rainbowTable);
    return lengthHash;
}

void * lookupResolverServiceThread(ThreadData * threadData)
{

    printf("GOT HASH LENGTH >>>%d \n", threadData->hashLength);


     // capture time
    struct timeval start, end;
    double elapsed_time;
    gettimeofday(&start, NULL);

    // Start indexing
    int counter = 0;
    Boolean isEndOfFile = FALSE;
    
    if (fseek(threadData->file, threadData->startPositionSeek, SEEK_SET) != 0) {
        printf("Erreur lors du déplacement du pointeur de fichier");
        pthread_exit(NULL);
    }

    while ( isEndOfFile == FALSE)
    {
        // log
        if(counter % 1000000 == 0) printf("INFO loading %d hashes...\n", counter);
        counter++;

        // read hash line and index it
        unsigned char hash[threadData->hashLength];
        size_t bytes_read = fread(hash, sizeof(unsigned char), threadData->hashLength, threadData->file);

        isEndOfFile = (ftell(threadData->file) >= threadData->endPositionSeek -1) ? TRUE : isEndOfFile; // end of file reached

        if (isEndOfFile == FALSE)
        {
            insertInHashTableML(threadData->hashTableML, hash, ftell(threadData->file), threadData->hashLength);

            // Move seek to end of line for be placed to start of next hash
            char octet;
            while (isEndOfFile == FALSE && fread(&octet, sizeof(char), 1, threadData->file) == 1)
            {
                if (octet == '\n') break;
            }
        }
    }

    // report time
    gettimeofday(&end, NULL);
    elapsed_time = (end.tv_sec - start.tv_sec) * 1000.0;    // Secondes en millisecondes
    elapsed_time += (end.tv_usec - start.tv_usec) / 1000.0; // Microsecondes en millisecondes
    printf("\n\nTime elapsed for indexing: %f millisecondes\n", elapsed_time);

   
}

void indexHashInHashTableMultiLayer(ArgumentsParsed *argumentsParsed, HashTableMultiLayer *hashTableML, FILE *rainbowTable, int hashLength ){

    printf("INFO Loading dict file: %s\n", argumentsParsed->inputFilename);

    
    // PREPARE AND LAUNCH MULTI THREAD
    int THREAD_COUNT = argumentsParsed->threadsCount;
    pthread_t threads[THREAD_COUNT];
    ThreadData * threadData[THREAD_COUNT];

    // PREPARE SEEK bucker for distribute read zone for each thread
    long * seekPositionBucket = (long *)malloc(sizeof(long) * THREAD_COUNT);
    long * seekEndHeader = 0;

    // save seek position after header 
    char line[1024];
    fgets(line, sizeof(line), rainbowTable);
    seekEndHeader = ftell(rainbowTable);

    rewind(rainbowTable);

    long max_seek;
    if (rainbowTable != NULL) {
        // GET end file seek position
        fseek(rainbowTable, 0, SEEK_END);  
        max_seek = ftell(rainbowTable);  

        if (max_seek != -1) {

            long seekStart = 0;
            long seekStep = max_seek / THREAD_COUNT; 

            // if first thread, position seek just after header
            for(int i = 0; i < THREAD_COUNT; i++) seekPositionBucket[i] = (i==0) ? (seekEndHeader) : (i * seekStep); 
            
            // don't move first seek, juste the other for each get position at a start of line
            for(int i = 1; i < THREAD_COUNT; i++){ 
                fseek(rainbowTable, seekPositionBucket[i], SEEK_SET);

                // move seek potion until next start of a line
                int c;
                while ((c = fgetc(rainbowTable)) != EOF) {
  
                    if (c == '\n') {
                        seekPositionBucket[i] = ftell(rainbowTable) + 1; // new position of seek is at a start of a line
                        break; 
                    }
                }
            }
            
        } else {
            printf("Can't get file size.\n");
        }
    } else {
        printf("Impossible d'ouvrir le fichier.\n");
    }

    for (int i = 0; i < THREAD_COUNT; i++) {
        threadData[i] = malloc(sizeof(ThreadData));
        threadData[i]->file = openFileForReadAsBin(argumentsParsed->inputFilename);
        threadData[i]->startPositionSeek = seekPositionBucket[i];
        threadData[i]->endPositionSeek = (i < THREAD_COUNT - 1) ? seekPositionBucket[i+1] : max_seek; // Dernier thread
        threadData[i]->argumentsParsed = argumentsParsed; 
        threadData[i]->hashLength = hashLength;
        threadData[i]->hashTableML = hashTableML;
        pthread_create(&threads[i], NULL, lookupResolverServiceThread, threadData[i]);
    }

    /*
    WAIT THREAD END
    */
    for (int i = 0; i < THREAD_COUNT; i++) pthread_join(threads[i], NULL);
        
    // Close file, free thread, free seek position bucket
    for (int i = 0; i < THREAD_COUNT; i++) { 
        closeFile(threadData[i]->file);
        free(threadData[i]);
    }
    free(seekPositionBucket);
}

void searchInHashTableMultiLayer(HashTableMultiLayer *hashTableML, FILE *instream, FILE *rainbowTable, int hashLength){

    /*
    SEARCH
    */
    char lineHashToGuess[2048];
    while (fgets(lineHashToGuess, sizeof(lineHashToGuess), instream) != NULL)
    {
        // capture time
        struct timeval start, end;
        double elapsed_time;
        gettimeofday(&start, NULL);

        // Convert hash string to bytes
        unsigned char hashToGessHasBytes[hashLength];
        hexStringToByteArray(lineHashToGuess, hashToGessHasBytes, hashLength);

        // Search in hashTable for retrieve seek position of clear pass in rainbow.table
        long seekPosOfClearPass = searchInHashTableML(hashTableML, hashToGessHasBytes, hashLength);

        // print clear pass from rainbowtable with retrieved seek
        if (seekPosOfClearPass > 0)
            printClearPass(rainbowTable, seekPosOfClearPass, hashToGessHasBytes, hashLength);
        // Move seek in rainbow table and check no error of reading

        // report time
        gettimeofday(&end, NULL);
        elapsed_time = (end.tv_sec - start.tv_sec) * 1000.0;    // Secondes en millisecondes
        elapsed_time += (end.tv_usec - start.tv_usec) / 1000.0; // Microsecondes en millisecondes
        printf("\n\nTime elapsed for Search: %f millisecondes for hash %s\n", elapsed_time, lineHashToGuess);
    }
}

int lookupResolverServiceMultiThread(ArgumentsParsed *argumentsParsed){
 
    // LOAD FILES
    FILE *rainbowTable = openFileForReadAsBin(argumentsParsed->inputFilename);
    FILE *instream = openFileForRead("/dev/stdin");

    // Create hashTable
    HashTableMultiLayer *hashTableML = createHashTableMultiLayer();
    
    // index hashes
    int HASH_LENGTH = findHashBytesLengthFromFile(rainbowTable);
    indexHashInHashTableMultiLayer(argumentsParsed, hashTableML, rainbowTable, HASH_LENGTH);

    // Search in hash table    
    searchInHashTableMultiLayer(hashTableML, instream, rainbowTable, HASH_LENGTH);
    
    // free hashtable
    closeFile(rainbowTable);
    closeFile(instream);
    freeHashTable(hashTableML);

    return 0;
}
