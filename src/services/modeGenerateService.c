#include "../utils/cryptoUtil.h"
#include "../utils/fileUtil.h"
#include "../utils/argumentsParserUtil.h"
#include <openssl/sha.h>
#include <openssl/md5.h>
#include "../types/argumentsParsed.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef void (*CallbackFunction)(char*, unsigned char *);

int generateResolverForSpecificHash(FILE *fileInput, FILE *fileOutput, ArgumentsParsed *argumentsParsed, CallbackFunction hashFunction)
{

    
    // read from file
    char line[2048];

    int counter = 0;
    char saut_de_ligne = '\n';

    size_t charSize = sizeof(char);
    char separateur = ':';

    // print in rainbow table an header with hash algo and byteLength
    fprintf(fileOutput, "%s\n", algorythmeToStr(argumentsParsed->algorythme));
    
    // browse clear pass and write hash in file
    while (fgets(line, sizeof(line), fileInput) != NULL)
    {
        // erase jump line char \n in pass for keep only pass
        int lineLength = strlen(line);
        line[lineLength - 1] = '\0';

        // hash clear pass
        unsigned char * hash = (unsigned char *)malloc(sizeof(unsigned char) * argumentsParsed->hashBytesLength);
        hashFunction(line, hash);
        
        // Write hash as bytes
        size_t bytes_written = fwrite(hash, sizeof(unsigned char), argumentsParsed->hashBytesLength, fileOutput);
        if (bytes_written != argumentsParsed->hashBytesLength)
        {
            printf("prbleme d'ecriture");
        }

        // Write separator
        fwrite(&separateur, charSize, 1, fileOutput);

        // Write clearPass
        size_t longueur = strlen(line);
        fwrite(line, 1, longueur, fileOutput);
        
        // write line jump
        fwrite(&saut_de_ligne, charSize, 1, fileOutput);

        // log
        if(counter % 1000000 == 0) printf("INFO %d hashes written...\n", counter);
        counter++;
        free(hash);
    }
    printf("INFO %d hashes written...\n", counter);
    return 1; // All finish with success
}

int generateResolverForSpecificHashAsString(FILE *fileInput, FILE *fileOutput, ArgumentsParsed *argumentsParsed, CallbackFunction hashFunction)
{

    char line[1024];
    int counter = 0;
    while (fgets(line, sizeof(line), fileInput) != NULL)
    {
        // erase jump line char \n in pass for keep only pass
        int lineLength = strlen(line);
        line[lineLength - 1] = '\0';

        // Hash clear pass
        unsigned char * hash = (unsigned char *)malloc(sizeof(unsigned char) * argumentsParsed->hashBytesLength);
        hashFunction(line, hash);

        // Convert to chars (2 chars by byte) and print each char
        for (int i = 0; i < argumentsParsed->hashBytesLength; i++)
        {
            fprintf(fileOutput, "%02x", hash[i]);
        }

        // Print clear pass prefixed by separato ':'
        fprintf(fileOutput, ":%s\n", line);
        // log
        if (counter % 1000000 == 0) printf("INFO %d hashes written...\n", counter);
        counter++;
        free(hash);
    }

    printf("INFO %d hashes written...\n", counter);
    return 1; // All finish with success
}


int generateResolverService(ArgumentsParsed *argumentsParsed)
{

    FILE *fileOutput = openFileForWriteAsBin(argumentsParsed->outputFilename);
    FILE *fileInput = openFileForRead(argumentsParsed->inputFilename);

    if (argumentsParsed->inputFilename == NULL)
    {
        // read from std in
    }
    else
    {
        
        if (argumentsParsed->algorythme == SHA_256) {
            argumentsParsed->execMode == MODE_G ? generateResolverForSpecificHash(fileInput, fileOutput, argumentsParsed, hashToSHA256) : generateResolverForSpecificHashAsString(fileInput, fileOutput, argumentsParsed, hashToSHA256);
        }
        if (argumentsParsed->algorythme == SHA_512) {
            argumentsParsed->execMode == MODE_G ? generateResolverForSpecificHash(fileInput, fileOutput, argumentsParsed, hashToSHA512) : generateResolverForSpecificHashAsString(fileInput, fileOutput, argumentsParsed, hashToSHA512);
        }
        if (argumentsParsed->algorythme == SHA_1) {
            argumentsParsed->execMode == MODE_G ? generateResolverForSpecificHash(fileInput, fileOutput, argumentsParsed, hashToSHA1) : generateResolverForSpecificHashAsString(fileInput, fileOutput, argumentsParsed, hashToSHA1);
        }
        if (argumentsParsed->algorythme == HASH_MD5) {
            argumentsParsed->execMode == MODE_G ? generateResolverForSpecificHash(fileInput, fileOutput, argumentsParsed, hashToMD5) : generateResolverForSpecificHashAsString(fileInput, fileOutput, argumentsParsed, hashToMD5);
        }
    }

    closeFile(fileInput);
    closeFile(fileOutput);
    return 1; // All finish with success
}
