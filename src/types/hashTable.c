#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "./hashTable.h"
#include <stdint.h>
#include "../types/hashTable.h"
#include "../enums/boolean.h"
#include "../utils/cryptoUtil.h"
#include <sys/time.h>

Boolean areByteArrayEquals(unsigned char *arr1, unsigned char *arr2, int length)
{
    Boolean equality = FALSE;
    int resultat = memcmp(arr1, arr2, length);

    if (resultat == 0)
        equality = TRUE;
    return equality;
}

HashTableMultiLayer *createHashTableMultiLayer()
{

    struct timeval start, end;
    double elapsed_time;

    gettimeofday(&start, NULL);

    HashTableMultiLayer *hashTableML;
    hashTableML = (HashTableMultiLayer *)malloc(sizeof(HashTableMultiLayer));

    for (int index = 0; index < UCHAR_MAX + 1; index++)
    {
        hashTableML->firstByteLayer[index] = (Layer_0_HashTable *)malloc(sizeof(Layer_0_HashTable));

        for (int i = 0; i < UCHAR_MAX + 1; i++)
        {
            hashTableML->firstByteLayer[index]->secondByteLayer[i] = (Layer_1_HashTable *)malloc(sizeof(Layer_1_HashTable));

            for (int idx = 0; idx < UCHAR_MAX + 1; idx++)
            {
                hashTableML->firstByteLayer[index]->secondByteLayer[i]->thirdByteLayer[idx] = (Layer_2_HashTable *)malloc(sizeof(Layer_2_HashTable));
            }
        }
    }

    gettimeofday(&end, NULL);
    elapsed_time = (end.tv_sec - start.tv_sec) * 1000.0;    // Secondes en millisecondes
    elapsed_time += (end.tv_usec - start.tv_usec) / 1000.0; // Microsecondes en millisecondes
    printf("\n\nTime elapsed for create and alloc hashtable: %f millisecondes\n", elapsed_time);
    return hashTableML;
}

void freeKeyValuePairChained(KeyValuePair *keyValuePairHead)
{

    KeyValuePair *prev = keyValuePairHead;
    KeyValuePair *tmp;

    while (prev != NULL)
    {
        tmp = prev->next;
        free(prev->hashValue);
        free(prev);
        prev = tmp;
    }
    return;
}

void freeHashTable(HashTableMultiLayer *hashTableML)
{
    for (int index = 0; index < UCHAR_MAX + 1; index++)
    {
        for (int i = 0; i < UCHAR_MAX + 1; i++)
        {
            for (int idx = 0; idx < UCHAR_MAX + 1; idx++)
            {
                freeKeyValuePairChained(hashTableML->firstByteLayer[index]->secondByteLayer[i]->thirdByteLayer[idx]->keyValuePairHead);
                free(hashTableML->firstByteLayer[index]->secondByteLayer[i]->thirdByteLayer[idx]);
            }
            free(hashTableML->firstByteLayer[index]->secondByteLayer[i]);
        }
        free(hashTableML->firstByteLayer[index]);
    }
    free(hashTableML);
    return;
}

void insertInHashTableML(HashTableMultiLayer *hashTableML, unsigned char hash[], long seekPos, int hashLength)
{


    KeyValuePair *keyValue = (KeyValuePair *)malloc(sizeof(KeyValuePair));
    keyValue->hashValue = (unsigned char *)malloc((hashLength + 1) * sizeof(unsigned char));
    keyValue->seekPos = seekPos + 1; // Add 1 for move the seek just after the separator, we can avoid using delimitator since we know the count of bytes used by the hash
    keyValue->next = NULL;
    memcpy(keyValue->hashValue, hash, hashLength);

    
    KeyValuePair *keyValuePairHead = hashTableML->firstByteLayer[(int)hash[0]]->secondByteLayer[(int)hash[1]]->thirdByteLayer[(int)hash[2]]->keyValuePairHead;

    if (keyValuePairHead == NULL)
    {
        hashTableML->firstByteLayer[(int)hash[0]]->secondByteLayer[(int)hash[1]]->thirdByteLayer[(int)hash[2]]->keyValuePairHead = keyValue;
        return;
    }
    pthread_mutex_lock(&keyValuePairHead->node_mutex);
    KeyValuePair *tmp = keyValuePairHead;
    while (tmp->next != NULL)
    {
        tmp = tmp->next;
    }
    tmp->next = keyValue;
    pthread_mutex_unlock(&keyValuePairHead->node_mutex);
    return;
};

long searchInHashTableML(HashTableMultiLayer *hashTableML, unsigned char hash[], int hashLength)
{

    struct timeval start, end;
    double elapsed_time;

    gettimeofday(&start, NULL);

    pthread_mutex_lock(&hashTableML->table_mutex);
    KeyValuePair *keyValuePairHead = hashTableML->firstByteLayer[(int)hash[0]]->secondByteLayer[(int)hash[1]]->thirdByteLayer[(int)hash[2]]->keyValuePairHead;
   

    if (keyValuePairHead == NULL)
    {
        printf("NOMATCH for ");
        printHashAsStr(hash, hashLength);
        printf("\n");
        pthread_mutex_unlock(&hashTableML->table_mutex);
        return 0;
    }
     pthread_mutex_lock(&keyValuePairHead->node_mutex);
    KeyValuePair *tmp = keyValuePairHead;
    while (tmp != NULL)
    {
        if (areByteArrayEquals(tmp->hashValue, hash, hashLength) == TRUE)
        {
            gettimeofday(&end, NULL);

            elapsed_time = (end.tv_sec - start.tv_sec) * 1000.0;    // Secondes en millisecondes
            elapsed_time += (end.tv_usec - start.tv_usec) / 1000.0; // Microsecondes en millisecondes

            printf("\n\nTemps écoulé total: %f millisecondes pour trouver 1 element dans la hashtable", elapsed_time);
            pthread_mutex_unlock(&keyValuePairHead->node_mutex);
            pthread_mutex_unlock(&hashTableML->table_mutex);
            return tmp->seekPos;
        }
        tmp = tmp->next;
    }

    printf("_2_ BIG ISSUE, HASH NOT FOUNC IN INDEX SEARCHING");
    pthread_mutex_unlock(&keyValuePairHead->node_mutex);
    pthread_mutex_unlock(&hashTableML->table_mutex);
    return 0;
};

void printHashTableML(HashTableMultiLayer *hashTableML, int hashLength)
{
    printf("___START print hashtable \n");

    for (int index = 0; index < UCHAR_MAX + 1; index++)
    {

        for (int i = 0; i < UCHAR_MAX + 1; i++)
        {

            for (int idx = 0; idx < UCHAR_MAX + 1; idx++)
            {

                KeyValuePair *tmp = hashTableML->firstByteLayer[index]->secondByteLayer[i]->thirdByteLayer[idx]->keyValuePairHead;
                while (tmp != NULL)
                {
                    printf("index %d , i %d, idx %d \n", index, i, idx);

                    printf("Has an entry for %02x, %02x, %02x \n", (unsigned char)index, (unsigned char)i, (unsigned char)idx);
                    printHashAsStr(tmp->hashValue, hashLength);
                    tmp = tmp->next;
                }
            }
        }
    }
    printf("END print hashtable \n");
}

void indexingHash(FILE *rainbowTable, HashTableMultiLayer *hashTableML, int hashLength)
{
    // capture time
    struct timeval start, end;
    double elapsed_time;
    gettimeofday(&start, NULL);

    // Start indexing
    int counter = 0;
    Boolean isEndOfFile = FALSE;
    
    while (!feof(rainbowTable) && isEndOfFile == FALSE)
    {
        // log
        if(counter % 1000000 == 0) printf("INFO loading %d hashes...\n", counter);
        counter++;

        unsigned char hash[hashLength];
        size_t bytes_read = fread(hash, sizeof(unsigned char), hashLength, rainbowTable);

        if (bytes_read != hashLength) // end of file reached
        {
            isEndOfFile = TRUE;
            rewind(rainbowTable);
        }

        if (isEndOfFile == FALSE)
        {
            insertInHashTableML(hashTableML, hash, ftell(rainbowTable), hashLength);

            char octet;
            // Move seek to end of file for be placed to start of next hash
            while (!feof(rainbowTable) && fread(&octet, sizeof(char), 1, rainbowTable) == 1)
            {
                if (octet == '\n')
                {
                    break;
                }
            }
        }
    }

    // report time
    gettimeofday(&end, NULL);
    elapsed_time = (end.tv_sec - start.tv_sec) * 1000.0;    // Secondes en millisecondes
    elapsed_time += (end.tv_usec - start.tv_usec) / 1000.0; // Microsecondes en millisecondes
    printf("\n\nTime elapsed for indexing: %f millisecondes\n", elapsed_time);
}
