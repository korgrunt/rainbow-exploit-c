#include "./constants/messages.h"
#include "./enums/boolean.h"
#include "./enums/execMode.h"
#include "./types/argumentsParsed.h"
#include "./utils/stringUtil.h"
#include "./utils/argumentsParserUtil.h"
#include "./utils/cryptoUtil.h"
#include "./services/modeGenerateService.h"
#include "./services/modeLookupService.h"
#include <stdio.h>
#include <sys/time.h>

int main(int argc, char **argv)
{

   printf("%s", START_MESSAGE);
   // KEEP time for perf benchmark
   struct timeval start, end;
   double elapsed_time;

   // Enregistrez le temps de début
   gettimeofday(&start, NULL);

   if (argc <= 1)
   {
      printf("%s", NOT_ENOUGH_ARGS);
      return 1;
   }

   // Parsing arguments
   ArgumentsParsed *argParsed = parseArgument(argc, argv);

   if (argParsed->isValid == FALSE)
   {
      printf("%s", BAD_ARGUMENT);
      return 1;
   }

   // Execute programme in two differentes modes
   if (argParsed->execMode == MODE_G || argParsed->execMode == MODE_C)
   {
      generateResolverService(argParsed);
   }
   else if (argParsed->execMode == MODE_L)
   {
      lookupResolverServiceMultiThread(argParsed);
   }
   else
   {
      printf("%s", UNKNOW_MODE_EXEC);
      return 1;
   }
   
   // libére l'espace memoire des argument parsé
   freeArgParsed(argParsed);

   // Save time end operation
   gettimeofday(&end, NULL);

   // calcule time elapsed in milli second
   elapsed_time = (end.tv_sec - start.tv_sec) * 1000.0;    // Secondes en millisecondes
   elapsed_time += (end.tv_usec - start.tv_usec) / 1000.0; // Microsecondes en millisecondes

   printf("\n\nTemps écoulé total: %f millisecondes\n", elapsed_time);
   printf("\n\n Soustraire le temps post indexation avec le temps total pour avoir le temps mis par l'indexation");

   // Cannot be reached, if reached. It caused by code modification
   return 1;
}
